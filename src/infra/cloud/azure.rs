//! Azure cloud provider implementation

use super::{CloudDeploymentConfig, CloudDeploymentResult, CloudProviderOps, DeployedResource};
use anyhow::{Context, Result};
use async_trait::async_trait;
use std::path::PathBuf;
use tracing::{info, warn};

use crate::common::output::{print_info, print_step, print_success};
use crate::infra::terraform::TerraformExecutor;

/// Azure cloud provider
pub struct AzureProvider {
    terraform_dir: PathBuf,
}

impl AzureProvider {
    /// Create a new Azure provider
    pub fn new(terraform_dir: impl Into<PathBuf>) -> Self {
        Self {
            terraform_dir: terraform_dir.into(),
        }
    }

    /// Create Terraform variables file
    async fn create_tfvars(&self, config: &CloudDeploymentConfig) -> Result<PathBuf> {
        let tfvars_path = self.terraform_dir.join("terraform.tfvars");

        let content = format!(
            r#"
# Generated by llm-analytics CLI
location = "{}"
environment = "{}"
cluster_name = "{}"
deploy_databases = {}
enable_monitoring = {}

# AKS Configuration
aks_kubernetes_version = "1.28"
aks_node_count = 3
aks_node_vm_size = "Standard_D4s_v3"
aks_min_count = 2
aks_max_count = 5

# PostgreSQL Configuration
postgres_sku_name = "GP_Standard_D4s_v3"
postgres_storage_mb = 102400
postgres_version = "14"

# Redis Configuration
redis_sku_name = "Premium"
redis_family = "P"
redis_capacity = 1

# Event Hubs Configuration
eventhub_sku = "Standard"
eventhub_capacity = 2
eventhub_partition_count = 32
eventhub_message_retention = 7

# Tags
tags = {{
{}
}}
"#,
            config.region,
            config.environment,
            config.cluster_name,
            config.deploy_databases,
            config.enable_monitoring,
            config
                .tags
                .iter()
                .map(|(k, v)| format!("  {} = \"{}\"", k, v))
                .collect::<Vec<_>>()
                .join("\n")
        );

        tokio::fs::write(&tfvars_path, content)
            .await
            .context("Failed to write tfvars file")?;

        Ok(tfvars_path)
    }

    /// Configure kubectl for AKS
    async fn configure_kubectl(
        &self,
        cluster_name: &str,
        resource_group: &str,
    ) -> Result<()> {
        info!("Configuring kubectl for AKS cluster");

        use crate::common::executor::CommandExecutor;

        let executor = CommandExecutor::new();
        executor
            .execute(
                "az",
                &[
                    "aks",
                    "get-credentials",
                    "--name",
                    cluster_name,
                    "--resource-group",
                    resource_group,
                    "--overwrite-existing",
                ],
                None,
            )
            .await
            .context("Failed to configure kubectl")?;

        Ok(())
    }

    /// Get Azure subscription ID from environment
    fn get_subscription_id() -> Result<String> {
        std::env::var("AZURE_SUBSCRIPTION_ID")
            .context("AZURE_SUBSCRIPTION_ID environment variable not set")
    }

    /// Get or create resource group name
    fn get_resource_group(config: &CloudDeploymentConfig) -> String {
        format!("rg-{}-{}", config.cluster_name, config.environment)
    }
}

#[async_trait]
impl CloudProviderOps for AzureProvider {
    async fn validate_prerequisites(&self) -> Result<()> {
        info!("Validating Azure prerequisites");

        // Check az CLI
        use crate::common::executor::CommandExecutor;
        if !CommandExecutor::command_exists("az") {
            anyhow::bail!("Azure CLI not found. Please install: https://docs.microsoft.com/en-us/cli/azure/install-azure-cli");
        }

        // Check Terraform
        if !TerraformExecutor::check_installed().await? {
            anyhow::bail!(
                "Terraform not found. Please install: https://www.terraform.io/downloads"
            );
        }

        // Check kubectl
        if !CommandExecutor::command_exists("kubectl") {
            anyhow::bail!("kubectl not found. Please install: https://kubernetes.io/docs/tasks/tools/");
        }

        // Verify Azure authentication
        let executor = CommandExecutor::new();
        match executor.execute("az", &["account", "show"], None).await {
            Ok(_) => {
                print_success("Azure credentials configured");
                Ok(())
            }
            Err(_) => {
                anyhow::bail!("Azure credentials not configured. Run: az login");
            }
        }
    }

    async fn deploy(&self, config: &CloudDeploymentConfig) -> Result<CloudDeploymentResult> {
        info!("Starting Azure deployment");

        // Validate prerequisites
        print_step(1, 6, "Validating prerequisites");
        self.validate_prerequisites().await?;
        let subscription_id = Self::get_subscription_id().unwrap_or_else(|_| "default".to_string());
        print_success(&format!("Prerequisites validated (subscription: {})", subscription_id));

        // Create Terraform variables
        print_step(2, 6, "Creating Terraform configuration");
        let tfvars_path = self.create_tfvars(config).await?;
        print_success("Terraform configuration created");

        // Initialize Terraform
        print_step(3, 6, "Initializing Terraform");
        let terraform = TerraformExecutor::new(&self.terraform_dir);
        terraform.init(true).await?;
        print_success("Terraform initialized");

        // Validate Terraform
        print_step(4, 6, "Validating Terraform configuration");
        terraform.validate().await?;
        print_success("Terraform configuration valid");

        // Plan Terraform
        print_step(5, 6, "Planning infrastructure changes");
        terraform.plan(Some(&tfvars_path)).await?;
        print_info("Review the plan above");

        // Apply Terraform
        print_step(6, 6, "Applying infrastructure changes");
        terraform.apply(Some(&tfvars_path), true, true).await?;
        print_success("Infrastructure deployed");

        // Get outputs
        let cluster_endpoint = terraform
            .output("cluster_endpoint")
            .await
            .unwrap_or_default();
        let resource_group = Self::get_resource_group(config);

        // Configure kubectl
        self.configure_kubectl(&config.cluster_name, &resource_group)
            .await?;

        // Build result
        let mut resources = vec![DeployedResource {
            resource_type: "AKS Cluster".to_string(),
            name: config.cluster_name.clone(),
            id: format!("{}-{}", config.cluster_name, config.region),
            endpoint: Some(cluster_endpoint.clone()),
        }];

        if config.deploy_databases {
            resources.push(DeployedResource {
                resource_type: "Azure Database for PostgreSQL".to_string(),
                name: format!("{}-postgres", config.cluster_name),
                id: "postgres-id".to_string(),
                endpoint: Some("postgres-endpoint".to_string()),
            });

            resources.push(DeployedResource {
                resource_type: "Azure Cache for Redis".to_string(),
                name: format!("{}-redis", config.cluster_name),
                id: "redis-id".to_string(),
                endpoint: Some("redis-endpoint".to_string()),
            });

            resources.push(DeployedResource {
                resource_type: "Event Hubs".to_string(),
                name: format!("{}-eventhubs", config.cluster_name),
                id: "eventhubs-id".to_string(),
                endpoint: Some("eventhubs-endpoint".to_string()),
            });
        }

        Ok(CloudDeploymentResult {
            success: true,
            cluster_endpoint: Some(cluster_endpoint),
            kubeconfig_path: None,
            resources,
            messages: vec!["Azure deployment completed successfully".to_string()],
        })
    }

    async fn destroy(&self, config: &CloudDeploymentConfig) -> Result<()> {
        info!("Destroying Azure infrastructure");

        self.validate_prerequisites().await?;
        let tfvars_path = self.create_tfvars(config).await?;

        let terraform = TerraformExecutor::new(&self.terraform_dir);
        terraform.destroy(Some(&tfvars_path), true, true).await?;

        print_success("Azure infrastructure destroyed");

        Ok(())
    }

    async fn status(&self, _config: &CloudDeploymentConfig) -> Result<CloudDeploymentResult> {
        info!("Getting Azure deployment status");

        warn!("Status check not fully implemented");

        Ok(CloudDeploymentResult {
            success: true,
            cluster_endpoint: None,
            kubeconfig_path: None,
            resources: vec![],
            messages: vec!["Status check completed".to_string()],
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_azure_provider_creation() {
        let provider = AzureProvider::new("/tmp/terraform/azure");
        assert_eq!(
            provider.terraform_dir,
            PathBuf::from("/tmp/terraform/azure")
        );
    }

    #[test]
    fn test_resource_group_naming() {
        let config = CloudDeploymentConfig::new(
            super::super::CloudProvider::Azure,
            "prod",
            "eastus",
        );
        let rg = AzureProvider::get_resource_group(&config);
        assert_eq!(rg, "rg-llm-analytics-prod-prod");
    }
}

//! AWS cloud provider implementation

use super::{CloudDeploymentConfig, CloudDeploymentResult, CloudProviderOps, DeployedResource};
use anyhow::{Context, Result};
use async_trait::async_trait;
use std::path::PathBuf;
use tracing::{info, warn};

use crate::common::output::{print_info, print_step, print_success};
use crate::infra::terraform::TerraformExecutor;

/// AWS cloud provider
pub struct AwsProvider {
    terraform_dir: PathBuf,
}

impl AwsProvider {
    /// Create a new AWS provider
    pub fn new(terraform_dir: impl Into<PathBuf>) -> Self {
        Self {
            terraform_dir: terraform_dir.into(),
        }
    }

    /// Get AWS region from config or environment
    #[allow(dead_code)]
    fn get_region(config: &CloudDeploymentConfig) -> String {
        config.region.clone()
    }

    /// Create Terraform variables file
    async fn create_tfvars(&self, config: &CloudDeploymentConfig) -> Result<PathBuf> {
        let tfvars_path = self.terraform_dir.join("terraform.tfvars");

        let content = format!(
            r#"
# Generated by llm-analytics CLI
region = "{}"
environment = "{}"
cluster_name = "{}"
deploy_databases = {}
enable_monitoring = {}

# EKS Configuration
eks_version = "1.28"
node_instance_type = "t3.large"
node_desired_capacity = 3
node_min_capacity = 2
node_max_capacity = 5

# RDS Configuration
rds_instance_class = "db.t3.large"
rds_allocated_storage = 100
rds_engine_version = "14.9"

# ElastiCache Configuration
elasticache_node_type = "cache.t3.medium"
elasticache_num_cache_nodes = 2

# MSK Configuration
msk_instance_type = "kafka.t3.small"
msk_number_of_broker_nodes = 3
msk_kafka_version = "3.5.1"

# Tags
tags = {{
{}
}}
"#,
            config.region,
            config.environment,
            config.cluster_name,
            config.deploy_databases,
            config.enable_monitoring,
            config
                .tags
                .iter()
                .map(|(k, v)| format!("  {} = \"{}\"", k, v))
                .collect::<Vec<_>>()
                .join("\n")
        );

        tokio::fs::write(&tfvars_path, content)
            .await
            .context("Failed to write tfvars file")?;

        Ok(tfvars_path)
    }

    /// Configure kubectl for EKS
    async fn configure_kubectl(&self, cluster_name: &str, region: &str) -> Result<()> {
        info!("Configuring kubectl for EKS cluster");

        use crate::common::executor::CommandExecutor;

        let executor = CommandExecutor::new();
        executor
            .execute(
                "aws",
                &[
                    "eks",
                    "update-kubeconfig",
                    "--name",
                    cluster_name,
                    "--region",
                    region,
                ],
                None,
            )
            .await
            .context("Failed to configure kubectl")?;

        Ok(())
    }
}

#[async_trait]
impl CloudProviderOps for AwsProvider {
    async fn validate_prerequisites(&self) -> Result<()> {
        info!("Validating AWS prerequisites");

        // Check AWS CLI
        use crate::common::executor::CommandExecutor;
        if !CommandExecutor::command_exists("aws") {
            anyhow::bail!("AWS CLI not found. Please install: https://aws.amazon.com/cli/");
        }

        // Check Terraform
        if !TerraformExecutor::check_installed().await? {
            anyhow::bail!(
                "Terraform not found. Please install: https://www.terraform.io/downloads"
            );
        }

        // Check kubectl
        if !CommandExecutor::command_exists("kubectl") {
            anyhow::bail!("kubectl not found. Please install: https://kubernetes.io/docs/tasks/tools/");
        }

        // Verify AWS credentials
        let executor = CommandExecutor::new();
        match executor.execute("aws", &["sts", "get-caller-identity"], None).await {
            Ok(_) => {
                print_success("AWS credentials configured");
                Ok(())
            }
            Err(_) => {
                anyhow::bail!("AWS credentials not configured. Run: aws configure");
            }
        }
    }

    async fn deploy(&self, config: &CloudDeploymentConfig) -> Result<CloudDeploymentResult> {
        info!("Starting AWS deployment");

        // Validate prerequisites
        print_step(1, 6, "Validating prerequisites");
        self.validate_prerequisites().await?;
        print_success("Prerequisites validated");

        // Create Terraform variables
        print_step(2, 6, "Creating Terraform configuration");
        let tfvars_path = self.create_tfvars(config).await?;
        print_success("Terraform configuration created");

        // Initialize Terraform
        print_step(3, 6, "Initializing Terraform");
        let terraform = TerraformExecutor::new(&self.terraform_dir);
        terraform.init(true).await?;
        print_success("Terraform initialized");

        // Validate Terraform
        print_step(4, 6, "Validating Terraform configuration");
        terraform.validate().await?;
        print_success("Terraform configuration valid");

        // Plan Terraform
        print_step(5, 6, "Planning infrastructure changes");
        terraform.plan(Some(&tfvars_path)).await?;
        print_info("Review the plan above");

        // Apply Terraform
        print_step(6, 6, "Applying infrastructure changes");
        terraform.apply(Some(&tfvars_path), true, true).await?;
        print_success("Infrastructure deployed");

        // Get outputs
        let cluster_endpoint = terraform
            .output("cluster_endpoint")
            .await
            .unwrap_or_default();
        let kubeconfig_path = std::env::var("KUBECONFIG")
            .ok()
            .or_else(|| {
                dirs::home_dir().map(|h| h.join(".kube/config").to_string_lossy().to_string())
            });

        // Configure kubectl
        self.configure_kubectl(&config.cluster_name, &config.region)
            .await?;

        // Build result
        let mut resources = vec![DeployedResource {
            resource_type: "EKS Cluster".to_string(),
            name: config.cluster_name.clone(),
            id: format!("{}-{}", config.cluster_name, config.region),
            endpoint: Some(cluster_endpoint.clone()),
        }];

        if config.deploy_databases {
            // Add database resources (would be parsed from terraform output in production)
            resources.push(DeployedResource {
                resource_type: "RDS".to_string(),
                name: format!("{}-rds", config.cluster_name),
                id: "rds-instance-id".to_string(),
                endpoint: Some("rds-endpoint".to_string()),
            });

            resources.push(DeployedResource {
                resource_type: "ElastiCache".to_string(),
                name: format!("{}-redis", config.cluster_name),
                id: "elasticache-id".to_string(),
                endpoint: Some("redis-endpoint".to_string()),
            });

            resources.push(DeployedResource {
                resource_type: "MSK".to_string(),
                name: format!("{}-kafka", config.cluster_name),
                id: "msk-id".to_string(),
                endpoint: Some("kafka-endpoint".to_string()),
            });
        }

        Ok(CloudDeploymentResult {
            success: true,
            cluster_endpoint: Some(cluster_endpoint),
            kubeconfig_path,
            resources,
            messages: vec!["AWS deployment completed successfully".to_string()],
        })
    }

    async fn destroy(&self, config: &CloudDeploymentConfig) -> Result<()> {
        info!("Destroying AWS infrastructure");

        // Validate prerequisites
        self.validate_prerequisites().await?;

        // Create Terraform variables
        let tfvars_path = self.create_tfvars(config).await?;

        // Destroy with Terraform
        let terraform = TerraformExecutor::new(&self.terraform_dir);
        terraform.destroy(Some(&tfvars_path), true, true).await?;

        print_success("AWS infrastructure destroyed");

        Ok(())
    }

    async fn status(&self, _config: &CloudDeploymentConfig) -> Result<CloudDeploymentResult> {
        info!("Getting AWS deployment status");

        // In production, this would query AWS APIs for actual status
        // For now, return a placeholder

        warn!("Status check not fully implemented");

        Ok(CloudDeploymentResult {
            success: true,
            cluster_endpoint: None,
            kubeconfig_path: None,
            resources: vec![],
            messages: vec!["Status check completed".to_string()],
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_aws_provider_creation() {
        let provider = AwsProvider::new("/tmp/terraform/aws");
        assert_eq!(
            provider.terraform_dir,
            PathBuf::from("/tmp/terraform/aws")
        );
    }
}

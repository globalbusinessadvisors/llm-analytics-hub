//! GCP cloud provider implementation

use super::{CloudDeploymentConfig, CloudDeploymentResult, CloudProviderOps, DeployedResource};
use anyhow::{Context, Result};
use async_trait::async_trait;
use std::path::PathBuf;
use tracing::{info, warn};

use crate::common::output::{print_info, print_step, print_success};
use crate::infra::terraform::TerraformExecutor;

/// GCP cloud provider
pub struct GcpProvider {
    terraform_dir: PathBuf,
}

impl GcpProvider {
    /// Create a new GCP provider
    pub fn new(terraform_dir: impl Into<PathBuf>) -> Self {
        Self {
            terraform_dir: terraform_dir.into(),
        }
    }

    /// Create Terraform variables file
    async fn create_tfvars(&self, config: &CloudDeploymentConfig) -> Result<PathBuf> {
        let tfvars_path = self.terraform_dir.join("terraform.tfvars");

        let content = format!(
            r#"
# Generated by llm-analytics CLI
region = "{}"
zone = "{}-a"
environment = "{}"
cluster_name = "{}"
deploy_databases = {}
enable_monitoring = {}

# GKE Configuration
gke_version = "1.28"
node_machine_type = "n1-standard-4"
node_count = 3
min_node_count = 2
max_node_count = 5

# Cloud SQL Configuration
cloudsql_tier = "db-n1-standard-2"
cloudsql_disk_size = 100
cloudsql_version = "POSTGRES_14"

# Memorystore Configuration
memorystore_memory_size_gb = 5
memorystore_tier = "STANDARD_HA"

# Pub/Sub Configuration
pubsub_message_retention_duration = "604800s"

# Tags
labels = {{
{}
}}
"#,
            config.region,
            config.region,
            config.environment,
            config.cluster_name,
            config.deploy_databases,
            config.enable_monitoring,
            config
                .tags
                .iter()
                .map(|(k, v)| format!("  {} = \"{}\"", k, v))
                .collect::<Vec<_>>()
                .join("\n")
        );

        tokio::fs::write(&tfvars_path, content)
            .await
            .context("Failed to write tfvars file")?;

        Ok(tfvars_path)
    }

    /// Configure kubectl for GKE
    async fn configure_kubectl(&self, cluster_name: &str, region: &str, project: &str) -> Result<()> {
        info!("Configuring kubectl for GKE cluster");

        use crate::common::executor::CommandExecutor;

        let executor = CommandExecutor::new();
        executor
            .execute(
                "gcloud",
                &[
                    "container",
                    "clusters",
                    "get-credentials",
                    cluster_name,
                    "--region",
                    region,
                    "--project",
                    project,
                ],
                None,
            )
            .await
            .context("Failed to configure kubectl")?;

        Ok(())
    }

    /// Get GCP project from environment
    fn get_project() -> Result<String> {
        std::env::var("GCP_PROJECT")
            .or_else(|_| std::env::var("GOOGLE_CLOUD_PROJECT"))
            .context("GCP_PROJECT or GOOGLE_CLOUD_PROJECT environment variable not set")
    }
}

#[async_trait]
impl CloudProviderOps for GcpProvider {
    async fn validate_prerequisites(&self) -> Result<()> {
        info!("Validating GCP prerequisites");

        // Check gcloud CLI
        use crate::common::executor::CommandExecutor;
        if !CommandExecutor::command_exists("gcloud") {
            anyhow::bail!("gcloud CLI not found. Please install: https://cloud.google.com/sdk/docs/install");
        }

        // Check Terraform
        if !TerraformExecutor::check_installed().await? {
            anyhow::bail!(
                "Terraform not found. Please install: https://www.terraform.io/downloads"
            );
        }

        // Check kubectl
        if !CommandExecutor::command_exists("kubectl") {
            anyhow::bail!("kubectl not found. Please install: https://kubernetes.io/docs/tasks/tools/");
        }

        // Verify GCP authentication
        let executor = CommandExecutor::new();
        match executor.execute("gcloud", &["auth", "list"], None).await {
            Ok(_) => {
                print_success("GCP credentials configured");
                Ok(())
            }
            Err(_) => {
                anyhow::bail!("GCP credentials not configured. Run: gcloud auth login");
            }
        }
    }

    async fn deploy(&self, config: &CloudDeploymentConfig) -> Result<CloudDeploymentResult> {
        info!("Starting GCP deployment");

        // Validate prerequisites
        print_step(1, 6, "Validating prerequisites");
        self.validate_prerequisites().await?;
        let project = Self::get_project()?;
        print_success(&format!("Prerequisites validated (project: {})", project));

        // Create Terraform variables
        print_step(2, 6, "Creating Terraform configuration");
        let tfvars_path = self.create_tfvars(config).await?;
        print_success("Terraform configuration created");

        // Initialize Terraform
        print_step(3, 6, "Initializing Terraform");
        let terraform = TerraformExecutor::new(&self.terraform_dir);
        terraform.init(true).await?;
        print_success("Terraform initialized");

        // Validate Terraform
        print_step(4, 6, "Validating Terraform configuration");
        terraform.validate().await?;
        print_success("Terraform configuration valid");

        // Plan Terraform
        print_step(5, 6, "Planning infrastructure changes");
        terraform.plan(Some(&tfvars_path)).await?;
        print_info("Review the plan above");

        // Apply Terraform
        print_step(6, 6, "Applying infrastructure changes");
        terraform.apply(Some(&tfvars_path), true, true).await?;
        print_success("Infrastructure deployed");

        // Get outputs
        let cluster_endpoint = terraform
            .output("cluster_endpoint")
            .await
            .unwrap_or_default();

        // Configure kubectl
        self.configure_kubectl(&config.cluster_name, &config.region, &project)
            .await?;

        // Build result
        let mut resources = vec![DeployedResource {
            resource_type: "GKE Cluster".to_string(),
            name: config.cluster_name.clone(),
            id: format!("{}-{}", config.cluster_name, config.region),
            endpoint: Some(cluster_endpoint.clone()),
        }];

        if config.deploy_databases {
            resources.push(DeployedResource {
                resource_type: "Cloud SQL".to_string(),
                name: format!("{}-postgres", config.cluster_name),
                id: "cloudsql-id".to_string(),
                endpoint: Some("cloudsql-endpoint".to_string()),
            });

            resources.push(DeployedResource {
                resource_type: "Memorystore".to_string(),
                name: format!("{}-redis", config.cluster_name),
                id: "memorystore-id".to_string(),
                endpoint: Some("redis-endpoint".to_string()),
            });

            resources.push(DeployedResource {
                resource_type: "Pub/Sub".to_string(),
                name: format!("{}-pubsub", config.cluster_name),
                id: "pubsub-id".to_string(),
                endpoint: None,
            });
        }

        Ok(CloudDeploymentResult {
            success: true,
            cluster_endpoint: Some(cluster_endpoint),
            kubeconfig_path: None,
            resources,
            messages: vec!["GCP deployment completed successfully".to_string()],
        })
    }

    async fn destroy(&self, config: &CloudDeploymentConfig) -> Result<()> {
        info!("Destroying GCP infrastructure");

        self.validate_prerequisites().await?;
        let tfvars_path = self.create_tfvars(config).await?;

        let terraform = TerraformExecutor::new(&self.terraform_dir);
        terraform.destroy(Some(&tfvars_path), true, true).await?;

        print_success("GCP infrastructure destroyed");

        Ok(())
    }

    async fn status(&self, _config: &CloudDeploymentConfig) -> Result<CloudDeploymentResult> {
        info!("Getting GCP deployment status");

        warn!("Status check not fully implemented");

        Ok(CloudDeploymentResult {
            success: true,
            cluster_endpoint: None,
            kubeconfig_path: None,
            resources: vec![],
            messages: vec!["Status check completed".to_string()],
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_gcp_provider_creation() {
        let provider = GcpProvider::new("/tmp/terraform/gcp");
        assert_eq!(
            provider.terraform_dir,
            PathBuf::from("/tmp/terraform/gcp")
        );
    }
}
